"""Aplicativo simples de gerenciamento de pentests.

Este script fornece um menu em linha de comando para administrar um
portfólio de pentests, permitindo cadastrar, listar, buscar,
atualizar métricas e remover registros. Os dados são persistidos em um
arquivo JSON localizado no mesmo diretório do script.
"""

from __future__ import annotations

import json
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Dict

ARQUIVO_DADOS = Path(__file__).with_name("pentest_data.json")


@dataclass
class Pentest:
    """Representa um pentest realizado para um cliente."""

    codigo: str
    cliente: str
    escopo: str
    pontuacao_cvss: float
    falhas_criticas: int


def carregar_pentests() -> Dict[str, Pentest]:
    """Carrega os pentests do arquivo JSON, se existir."""

    if not ARQUIVO_DADOS.exists():
        return {}

    try:
        conteudo = json.loads(ARQUIVO_DADOS.read_text(encoding="utf-8"))
    except json.JSONDecodeError:
        print("Arquivo de dados corrompido. Iniciando com portfólio vazio.")
        return {}

    pentests: Dict[str, Pentest] = {}
    for item in conteudo:
        try:
            pentest = Pentest(
                codigo=item["codigo"],
                cliente=item["cliente"],
                escopo=item["escopo"],
                pontuacao_cvss=float(item["pontuacao_cvss"]),
                falhas_criticas=int(item["falhas_criticas"]),
            )
        except (KeyError, TypeError, ValueError):
            print(f"Registro inválido encontrado e ignorado: {item}")
            continue
        pentests[pentest.codigo] = pentest
    return pentests


def salvar_pentests(pentests: Dict[str, Pentest]) -> None:
    """Salva os pentests no arquivo JSON."""

    dados = [asdict(pentest) for pentest in pentests.values()]
    ARQUIVO_DADOS.write_text(
        json.dumps(dados, indent=2, ensure_ascii=False), encoding="utf-8"
    )


def solicitar_float(mensagem: str) -> float:
    """Solicita um número decimal ao usuário."""

    while True:
        entrada = input(mensagem).strip().replace(",", ".")
        try:
            return float(entrada)
        except ValueError:
            print("Valor inválido. Tente novamente usando apenas números.")


def solicitar_int(mensagem: str) -> int:
    """Solicita um número inteiro ao usuário."""

    while True:
        entrada = input(mensagem).strip()
        try:
            return int(entrada)
        except ValueError:
            print("Valor inválido. Tente novamente com um número inteiro.")


def cadastrar_pentest(pentests: Dict[str, Pentest]) -> None:
    """Adiciona um novo pentest ao portfólio."""

    codigo = input("Código do pentest: ").strip()
    if not codigo:
        print("O código não pode ficar vazio.")
        return

    if codigo in pentests:
        print("Já existe um pentest com esse código.")
        return

    cliente = input("Cliente: ").strip()
    escopo = input("Escopo avaliado: ").strip()
    pontuacao_cvss = solicitar_float("Pontuação CVSS média: ")
    falhas_criticas = solicitar_int("Falhas críticas identificadas: ")

    pentests[codigo] = Pentest(codigo, cliente, escopo, pontuacao_cvss, falhas_criticas)
    salvar_pentests(pentests)
    print("Pentest cadastrado com sucesso!")


def listar_pentests(pentests: Dict[str, Pentest]) -> None:
    """Lista todos os pentests cadastrados."""

    if not pentests:
        print("Nenhum pentest cadastrado.")
        return

    print("\nPortfólio de Pentests:")
    print("-" * 60)
    for pentest in pentests.values():
        print(
            f"Código: {pentest.codigo}\n"
            f"  Cliente: {pentest.cliente}\n"
            f"  Escopo: {pentest.escopo}\n"
            f"  Pontuação CVSS média: {pentest.pontuacao_cvss:.2f}\n"
            f"  Falhas críticas: {pentest.falhas_criticas}\n"
        )
    print("-" * 60)


def buscar_pentest(pentests: Dict[str, Pentest]) -> None:
    """Busca um pentest pelo código."""

    codigo = input("Informe o código a buscar: ").strip()
    pentest = pentests.get(codigo)
    if pentest is None:
        print("Pentest não encontrado.")
        return

    print(
        f"Código: {pentest.codigo}\n"
        f"Cliente: {pentest.cliente}\n"
        f"Escopo: {pentest.escopo}\n"
        f"Pontuação CVSS média: {pentest.pontuacao_cvss:.2f}\n"
        f"Falhas críticas: {pentest.falhas_criticas}"
    )


def atualizar_falhas(pentests: Dict[str, Pentest]) -> None:
    """Atualiza a quantidade de falhas críticas de um pentest."""

    codigo = input("Código do pentest: ").strip()
    pentest = pentests.get(codigo)
    if pentest is None:
        print("Pentest não encontrado.")
        return

    quantidade = solicitar_int("Nova quantidade de falhas críticas: ")
    pentest.falhas_criticas = quantidade
    salvar_pentests(pentests)
    print("Métricas atualizadas com sucesso!")


def remover_pentest(pentests: Dict[str, Pentest]) -> None:
    """Remove um pentest do portfólio."""

    codigo = input("Código do pentest a remover: ").strip()
    if codigo not in pentests:
        print("Pentest não encontrado.")
        return

    del pentests[codigo]
    salvar_pentests(pentests)
    print("Pentest removido com sucesso!")


def exibir_menu() -> None:
    """Mostra o menu principal."""

    print(
        "\n=== Sistema de Gestão de Pentests ===\n"
        "1. Cadastrar pentest\n"
        "2. Listar pentests\n"
        "3. Buscar pentest\n"
        "4. Atualizar falhas críticas\n"
        "5. Remover pentest\n"
        "0. Sair"
    )


def executar() -> None:
    """Loop principal do programa."""

    pentests = carregar_pentests()

    while True:
        exibir_menu()
        opcao = input("Escolha uma opção: ").strip()

        if opcao == "1":
            cadastrar_pentest(pentests)
        elif opcao == "2":
            listar_pentests(pentests)
        elif opcao == "3":
            buscar_pentest(pentests)
        elif opcao == "4":
            atualizar_falhas(pentests)
        elif opcao == "5":
            remover_pentest(pentests)
        elif opcao == "0":
            print("Saindo... Até logo!")
            break
        else:
            print("Opção inválida. Tente novamente.")


if __name__ == "__main__":
    executar()
